# 实验 2.1 分治算法

## 学号：20201060353  

## （一）实验目的：  
通过排序算法的程序实现和执行时间测试，与理论上的结论进行对比分析，
深入理解算法时间复杂度渐进性态和和增长率的概念；理解分治算法设计的基本
思想、递归程序实现的基本方法，加深对分治算法设计与分析思想的理解。

## （二）实验原理：
### 1.算法时间复杂度分析的相关概念
算法的计算时间取决于算法中某些操作的执行次数，这些操作是算法时
间复杂度分析的依据。增长率反映了算法的计算时间复杂度，即随着算法输入规
模的增加、算法计算时间增加的趋势。算法的计算时间复杂度针对输入数据的等
价类来分析或测试。
### 2. 随机数生成算法
通过程序生成（伪）随机数，作为实验用测试数据。可使用编程语言自带的
random 函数生成，也可以采用一些有效的随机数生成算法生成，例如“线性同
余法”，基于该算法，只要参数选择合适，所产生的伪随机数就能满足均匀性和
独立性，与真正的随机数具有相近的性质。该算法的基本思想如下：
通过设置 Xi+1=(aXi+c) mod m, n0，其中的 4 个整数参数：m——模数, m>0； a——乘数, 0a<m；c——增量, 0c<m；X0——开始值, 0X0<m。这样得到所求
的随机数序列{Xi}，称作线形同余序列。
### 3.分治算法
分治算法的基本思想是将一个规模为 n 的问题分解为 k 个规模较小的子问
题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问
题的解。分治算法设计的一般步骤包括：
(1) 分解，将要解决的问题划分成若干规模较小的同类问题；
4
(2) 求解，当子问题划分得足够小时，用较简单的方法解决；
(3) 合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。
分治法的基本设计范式如下：
DivideAndConquer(data,n,solution) 
if(n≤SizeLimit) then 
DirectSolution(data,n,solution) 
else 
DivideInput(data,n,smallerSets,smallerSizes,numberSmaller) 
for i=1 to numberSmaller do 
DivideAndConquer(smallerSets[i],smallerSizes[i],smallerSol
ution[i]) 
end for 
CombineSolutions(smallerSolution,numberSmaller,solution) 
end if
### 4.测试算法
以冒泡排序、合并排序和快速排序算法为例，这三个算法如下：
(1) BubbleSort (list, n) 
numberOfPairs=n 
swappedElements=true 
while swappedElements do 
 numberOfPairs=numberOfPairs-1 
 swappedElements=false 
 for i=1 to numberOfPairs do 
 if list[i]>list[i+1] then 
 swap(list[i],list[i+1]) 
 swappedElements=true 
 end if 
 end for 
(2) MergeSort(list, first, last) 
if first<last then 
 middle=(first+last)/2 
 MergeSort(list, first, middle) 
 MergeSort(list, middle+1, last) 
 MergeLists(list, first, middle, middle+1, last) 
end if 
5
MergeLists(list, start1, end1, start2, end2) 
while (start1≤end1) and (start2≤end2) do 
 if list[start1] < list[start2] then 
 result[indexC]=list[start1] 
 start1=start1+1 
 else 
 result[indexC]=list[start2] 
 start2=start2+1 
end if 
indexC=indexC+1 
end while 
if start1≤end1 then 
 for i=start1 to end1 do 
 result[indexC]=list[i] 
 indexC=indexC+1 
 end for 
else 
 for i=start2 to end2 do 
 result[indexC]=list[i] 
 indexC=indexC+1 
 end for 
indexC=1 
for i=finalStart to finalEnd do 
 list[i]=result[indexC] 
 indexC=indexC+1 
end for 
(3) QuickSort(list, first, last)
if first<last then 
 pivot=PivotList(list, first, last) 
 QuickSort(list, first, pivot-1) 
 QuickSort(list, pivot+1, last) 
end if 
PivotList (list, first, last) 
PivotValue=list[first] 
PivotPoint=first 
for index=first+1 to last do 
 if list[index]<PivotValue then 
6
 PivotPoint=PivotPoint+1 
 Swap(list[PivotPoint],list[index]) 
 end if 
end for 
Swap(list[first],list[PivotPoint] 
return PivotPoint

## （三）实验输入数据集
文本数据集：每次运用线性同余法得出不同数量的随机数集合

## （四）实验内容
###  1.要求：
以冒泡排序、合并排序和快速排序算法为例，以生成的随机数作为实验中使
用的测试数据。对每个算法，记录程序执行中随着测试数据增加算法基本操作执
行次数，分析并以图形方式展现增长率；对以上三个排序算法，对比随着测试数
据增加算法增长率变化趋势；测试、验证、对比算法时间复杂度的理论结论。
### 2.代码：
[实验代码](https://github.com/AlinaClr/homewrok_template/blob/main/code/sort.java#L21)

## （五）实验预期结果与实际结果
### 1.验证程序正确性：

#### 实验预期结果：有序序列

#### 实验过程及实验结果

gitpod /workspace/homewrok_template/code (main) $ cd "/workspace/homewrok_template/code/" && javac sort.java && java sort
Picked up JAVA_TOOL_OPTIONS:  -Xmx3435m
Picked up JAVA_TOOL_OPTIONS:  -Xmx3435m
请输入测试数据的数目
10
4274, 6504, 19395, 24194, 24263, 62045, 62778, 73284, 75905, 87426, 基本操作执行次数：23次
冒泡排序执行时间:12.441785ms
4274, 6504, 19395, 24194, 24263, 62045, 62778, 73284, 75905, 87426, 
归并排序基本操作执行次数：34次
归并排序执行时间：0.39882ms
4274, 6504, 19395, 24194, 24263, 62045, 62778, 73284, 75905, 87426, 
快速排序基本操作执行次数：9次
快速排序执行时间：0.45007ms

### 2.对比两次随机生成的100个测试数据和算法执行中比较操作的次数

#### 实验预期结果：两次随机生成的100个数据基本操作执行次数和时间相近

#### 实验过程及实验结果：

(1)代码运行结果：
①第一次生成100个随机数：
gitpod /workspace/homewrok_template/code (main) $ cd "/workspace/homewrok_template/code/" && javac sort.java && java sort
Picked up JAVA_TOOL_OPTIONS:  -Xmx3435m
Picked up JAVA_TOOL_OPTIONS:  -Xmx3435m
请输入测试数据的数目
100
112, 250, 356, 3336, 4771, 4885, 5176, 6666, 7187, 7898, 8633, 8791, 9121, 11541, 12447, 13435, 14810, 20175, 20525, 22375, 24123, 24331, 26872, 27415, 28299, 30476, 30559, 31015, 31893, 32603, 33177, 33284, 33618, 35567, 35806, 36695, 36779, 37009, 37521, 39966, 41238, 41290, 41520, 42413, 44164, 44455, 44707, 45621, 46148, 46337, 47606, 48833, 49297, 49591, 49733, 49977, 50567, 51465, 51642, 52571, 53440, 53500, 53998, 55129, 55327, 59234, 59411, 59888, 59899, 60917, 62128, 65122, 65157, 65415, 66168, 66497, 67091, 74273, 74414, 76268, 77357, 78099, 78339, 80608, 84736, 86008, 86639, 89042, 89287, 89494, 89540, 90841, 91035, 91396, 93105, 94612, 96446, 98123, 99015, 99760, 基本操作执行次数：2518次
冒泡排序执行时间:15.658384ms
112, 250, 356, 3336, 4771, 4885, 5176, 6666, 7187, 7898, 8633, 8791, 9121, 11541, 12447, 13435, 14810, 20175, 20525, 22375, 24123, 24331, 26872, 27415, 28299, 30476, 30559, 31015, 31893, 32603, 33177, 33284, 33618, 35567, 35806, 36695, 36779, 37009, 37521, 39966, 41238, 41290, 41520, 42413, 44164, 44455, 44707, 45621, 46148, 46337, 47606, 48833, 49297, 49591, 49733, 49977, 50567, 51465, 51642, 52571, 53440, 53500, 53998, 55129, 55327, 59234, 59411, 59888, 59899, 60917, 62128, 65122, 65157, 65415, 66168, 66497, 67091, 74273, 74414, 76268, 77357, 78099, 78339, 80608, 84736, 86008, 86639, 89042, 89287, 89494, 89540, 90841, 91035, 91396, 93105, 94612, 96446, 98123, 99015, 99760, 
归并排序基本操作执行次数：672次
归并排序执行时间：3.135018ms
112, 250, 356, 3336, 4771, 4885, 5176, 6666, 7187, 7898, 8633, 8791, 9121, 11541, 12447, 13435, 14810, 20175, 20525, 22375, 24123, 24331, 26872, 27415, 28299, 30476, 30559, 31015, 31893, 32603, 33177, 33284, 33618, 35567, 35806, 36695, 36779, 37009, 37521, 39966, 41238, 41290, 41520, 42413, 44164, 44455, 44707, 45621, 46148, 46337, 47606, 48833, 49297, 49591, 49733, 49977, 50567, 51465, 51642, 52571, 53440, 53500, 53998, 55129, 55327, 59234, 59411, 59888, 59899, 60917, 62128, 65122, 65157, 65415, 66168, 66497, 67091, 74273, 74414, 76268, 77357, 78099, 78339, 80608, 84736, 86008, 86639, 89042, 89287, 89494, 89540, 90841, 91035, 91396, 93105, 94612, 96446, 98123, 99015, 99760, 
快速排序基本操作执行次数：99次
快速排序执行时间：2.266869ms

②第二次生产100个随机数：
gitpod /workspace/homewrok_template/code (main) $ cd "/workspace/homewrok_template/code/" && javac sort.java && java sort
Picked up JAVA_TOOL_OPTIONS:  -Xmx3435m
Picked up JAVA_TOOL_OPTIONS:  -Xmx3435m
请输入测试数据的数目
100
158, 2193, 2241, 2512, 2532, 3950, 4256, 4470, 4571, 5605, 5660, 6390, 6474, 10871, 11187, 13673, 14787, 14913, 15083, 15767, 15805, 16721, 17655, 17736, 19296, 20219, 21234, 25525, 26036, 27120, 28850, 31422, 31974, 31992, 32571, 33585, 34104, 34304, 34787, 36469, 37888, 41210, 42282, 42779, 43342, 45123, 45284, 45356, 47052, 47060, 53008, 53165, 53627, 54643, 54906, 55933, 56156, 56762, 57725, 59201, 59478, 60156, 62712, 62727, 62909, 63696, 64317, 65173, 66688, 68900, 69292, 69567, 72318, 74840, 77219, 78511, 79135, 79695, 81530, 81898, 82508, 83807, 83842, 85118, 85253, 85607, 86421, 86615, 87117, 87495, 88789, 89415, 92627, 92933, 93123, 93302, 95737, 95746, 96169, 97974, 基本操作执行次数：2504次
冒泡排序执行时间:15.954344ms
158, 2193, 2241, 2512, 2532, 3950, 4256, 4470, 4571, 5605, 5660, 6390, 6474, 10871, 11187, 13673, 14787, 14913, 15083, 15767, 15805, 16721, 17655, 17736, 19296, 20219, 21234, 25525, 26036, 27120, 28850, 31422, 31974, 31992, 32571, 33585, 34104, 34304, 34787, 36469, 37888, 41210, 42282, 42779, 43342, 45123, 45284, 45356, 47052, 47060, 53008, 53165, 53627, 54643, 54906, 55933, 56156, 56762, 57725, 59201, 59478, 60156, 62712, 62727, 62909, 63696, 64317, 65173, 66688, 68900, 69292, 69567, 72318, 74840, 77219, 78511, 79135, 79695, 81530, 81898, 82508, 83807, 83842, 85118, 85253, 85607, 86421, 86615, 87117, 87495, 88789, 89415, 92627, 92933, 93123, 93302, 95737, 95746, 96169, 97974, 
归并排序基本操作执行次数：672次
归并排序执行时间：2.10585ms
158, 2193, 2241, 2512, 2532, 3950, 4256, 4470, 4571, 5605, 5660, 6390, 6474, 10871, 11187, 13673, 14787, 14913, 15083, 15767, 15805, 16721, 17655, 17736, 19296, 20219, 21234, 25525, 26036, 27120, 28850, 31422, 31974, 31992, 32571, 33585, 34104, 34304, 34787, 36469, 37888, 41210, 42282, 42779, 43342, 45123, 45284, 45356, 47052, 47060, 53008, 53165, 53627, 54643, 54906, 55933, 56156, 56762, 57725, 59201, 59478, 60156, 62712, 62727, 62909, 63696, 64317, 65173, 66688, 68900, 69292, 69567, 72318, 74840, 77219, 78511, 79135, 79695, 81530, 81898, 82508, 83807, 83842, 85118, 85253, 85607, 86421, 86615, 87117, 87495, 88789, 89415, 92627, 92933, 93123, 93302, 95737, 95746, 96169, 97974, 
快速排序基本操作执行次数：99次
快速排序执行时间：1.888059ms

(2)算法复杂度分析时输入数据等价类的含义：

### 2.使用随机数生成方法生成不同规模的测试数据对于每种规模的测试数据，分别记录 BubbleSort、MergeSort 和 QuickSort 算法执行中比较操作的执行次数

#### 实验预期结果：冒泡排序的基本操作次数最大，合并排序次之，快速排序最后。

#### 实验过程及实验结果：

(1)代码运行结果：

(2)加法操作与n的关系曲线图：
①冒泡排序：
![冒泡排序](![](https://s3.bmp.ovh/imgs/2022/06/19/d77890953798f6fe.png))
②动态规划法：
![动态规划](![](https://s3.bmp.ovh/imgs/2022/06/19/7ece6df5e0ab8832.png))

### 3.实验结果分析与结论：
①由(2)所画的曲线图分析可以得出，动态规划法的加法操作执行次数远小于分治法，并且分治法的曲线呈现指数型曲线，而动态规划法的曲线为线性曲线。与理论上动态规划法的时间复杂度为O（n)相吻合，使用动态规划法来解决斐波那契数列问题的效率远远高于分治法。

②我们知道斐波那契数列是子问题重叠的问题，实验证明使用动态规划法的效率远高于分治法。因此动态规划法适用于子问题重叠的问题，而分治法则适用于子问题独立的问题。








