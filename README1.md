# 实验 2.1 分治算法

## 学号：20201060353  

## （一）实验目的：  
通过排序算法的程序实现和执行时间测试，与理论上的结论进行对比分析，深入理解算法时间复杂度渐进性态和和增长率的概念；理解分治算法设计的基本思想、递归程序实现的基本方法，加深对分治算法设计与分析思想的理解。

## （二）实验原理：
### 1.算法时间复杂度分析的相关概念
算法的计算时间取决于算法中某些操作的执行次数，这些操作是算法时间复杂度分析的依据。增长率反映了算法的计算时间复杂度，即随着算法输入规模的增加、算法计算时间增加的趋势。算法的计算时间复杂度针对输入数据的等价类来分析或测试。
### 2. 随机数生成算法
通过程序生成（伪）随机数，作为实验用测试数据。可使用编程语言自带的random 函数生成，也可以采用一些有效的随机数生成算法生成，例如“线性同余法”，基于该算法，只要参数选择合适，所产生的伪随机数就能满足均匀性和独立性，与真正的随机数具有相近的性质。该算法的基本思想如下：通过设置 Xi+1=(aXi+c) mod m, n0，其中的 4 个整数参数：m——模数, m>0； a——乘数,；c——增量, 0c<m；X0——开始值, 0X0<m。这样得到所求的随机数序列{Xi}，称作线形同余序列。
### 3.分治算法
分治算法的基本思想是将一个规模为 n 的问题分解为 k 个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。分治算法设计的一般步骤包括：
(1) 分解，将要解决的问题划分成若干规模较小的同类问题；
(2) 求解，当子问题划分得足够小时，用较简单的方法解决；
(3) 合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。
分治法的基本设计范式如下：
DivideAndConquer(data,n,solution) 
if(n≤SizeLimit) then 
DirectSolution(data,n,solution) 
else 
DivideInput(data,n,smallerSets,smallerSizes,numberSmaller) 
for i=1 to numberSmaller do 
DivideAndConquer(smallerSets[i],smallerSizes[i],smallerSol
ution[i]) 
end for 
CombineSolutions(smallerSolution,numberSmaller,solution) 
end if
### 4.测试算法
以冒泡排序、合并排序和快速排序算法为例，这三个算法如下：
(1) BubbleSort (list, n) 
numberOfPairs=n 
swappedElements=true 
while swappedElements do 
 numberOfPairs=numberOfPairs-1 
 swappedElements=false 
 for i=1 to numberOfPairs do 
 if list[i]>list[i+1] then 
 swap(list[i],list[i+1]) 
 swappedElements=true 
 end if 
 end for 
(2) MergeSort(list, first, last) 
if first<last then 
 middle=(first+last)/2 
 MergeSort(list, first, middle) 
 MergeSort(list, middle+1, last) 
 MergeLists(list, first, middle, middle+1, last) 
end if 
MergeLists(list, start1, end1, start2, end2) 
while (start1≤end1) and (start2≤end2) do 
 if list[start1] < list[start2] then 
 result[indexC]=list[start1] 
 start1=start1+1 
 else 
 result[indexC]=list[start2] 
 start2=start2+1 
end if 
indexC=indexC+1 
end while 
if start1≤end1 then 
 for i=start1 to end1 do 
 result[indexC]=list[i] 
 indexC=indexC+1 
 end for 
else 
 for i=start2 to end2 do 
 result[indexC]=list[i] 
 indexC=indexC+1 
 end for 
indexC=1 
for i=finalStart to finalEnd do 
 list[i]=result[indexC] 
 indexC=indexC+1 
end for 
(3) QuickSort(list, first, last)
if first<last then 
 pivot=PivotList(list, first, last) 
 QuickSort(list, first, pivot-1) 
 QuickSort(list, pivot+1, last) 
end if 
PivotList (list, first, last) 
PivotValue=list[first] 
PivotPoint=first 
for index=first+1 to last do 
 if list[index]<PivotValue then 
 PivotPoint=PivotPoint+1 
 Swap(list[PivotPoint],list[index]) 
 end if 
end for 
Swap(list[first],list[PivotPoint] 
return PivotPoint

## （三）实验输入数据集
文本数据集：每次运用线性同余法得出不同数量的随机数集合

## （四）实验内容
###  1.要求：
以冒泡排序、合并排序和快速排序算法为例，以生成的随机数作为实验中使用的测试数据。对每个算法，记录程序执行中随着测试数据增加算法基本操作执行次数，分析并以图形方式展现增长率；对以上三个排序算法，对比随着测试数据增加算法增长率变化趋势；测试、验证、对比算法时间复杂度的理论结论。
### 2.代码：
[实验代码](https://github.com/AlinaClr/homewrok_template/blob/main/code/sort.java#L21)

## （五）实验预期结果与实际结果
### 1.验证程序正确性：

#### 实验预期结果：有序序列

#### 实验过程及实验结果

gitpod /workspace/homewrok_template/code (main) $ cd "/workspace/homewrok_template/code/" && javac sort.java && java sort
Picked up JAVA_TOOL_OPTIONS:  -Xmx3435m
Picked up JAVA_TOOL_OPTIONS:  -Xmx3435m
请输入测试数据的数目
10
4274, 6504, 19395, 24194, 24263, 62045, 62778, 73284, 75905, 87426, 基本操作执行次数：23次
冒泡排序执行时间:12.441785ms
4274, 6504, 19395, 24194, 24263, 62045, 62778, 73284, 75905, 87426, 
归并排序基本操作执行次数：34次
归并排序执行时间：0.39882ms
4274, 6504, 19395, 24194, 24263, 62045, 62778, 73284, 75905, 87426, 
快速排序基本操作执行次数：9次
快速排序执行时间：0.45007ms

### 2.对比两次随机生成的100个测试数据和算法执行中比较操作的次数

#### 实验预期结果：两次随机生成的100个数据基本操作执行次数和时间相近

#### 实验过程及实验结果：

(1)代码运行结果：
①第一次生成100个随机数：
gitpod /workspace/homewrok_template/code (main) $ cd "/workspace/homewrok_template/code/" && javac sort.java && java sort
Picked up JAVA_TOOL_OPTIONS:  -Xmx3435m
Picked up JAVA_TOOL_OPTIONS:  -Xmx3435m
请输入测试数据的数目
100
112, 250, 356, 3336, 4771, 4885, 5176, 6666, 7187, 7898, 8633, 8791, 9121, 11541, 12447, 13435, 14810, 20175, 20525, 22375, 24123, 24331, 26872, 27415, 28299, 30476, 30559, 31015, 31893, 32603, 33177, 33284, 33618, 35567, 35806, 36695, 36779, 37009, 37521, 39966, 41238, 41290, 41520, 42413, 44164, 44455, 44707, 45621, 46148, 46337, 47606, 48833, 49297, 49591, 49733, 49977, 50567, 51465, 51642, 52571, 53440, 53500, 53998, 55129, 55327, 59234, 59411, 59888, 59899, 60917, 62128, 65122, 65157, 65415, 66168, 66497, 67091, 74273, 74414, 76268, 77357, 78099, 78339, 80608, 84736, 86008, 86639, 89042, 89287, 89494, 89540, 90841, 91035, 91396, 93105, 94612, 96446, 98123, 99015, 99760, 基本操作执行次数：2518次
冒泡排序执行时间:15.658384ms
112, 250, 356, 3336, 4771, 4885, 5176, 6666, 7187, 7898, 8633, 8791, 9121, 11541, 12447, 13435, 14810, 20175, 20525, 22375, 24123, 24331, 26872, 27415, 28299, 30476, 30559, 31015, 31893, 32603, 33177, 33284, 33618, 35567, 35806, 36695, 36779, 37009, 37521, 39966, 41238, 41290, 41520, 42413, 44164, 44455, 44707, 45621, 46148, 46337, 47606, 48833, 49297, 49591, 49733, 49977, 50567, 51465, 51642, 52571, 53440, 53500, 53998, 55129, 55327, 59234, 59411, 59888, 59899, 60917, 62128, 65122, 65157, 65415, 66168, 66497, 67091, 74273, 74414, 76268, 77357, 78099, 78339, 80608, 84736, 86008, 86639, 89042, 89287, 89494, 89540, 90841, 91035, 91396, 93105, 94612, 96446, 98123, 99015, 99760, 
归并排序基本操作执行次数：672次
归并排序执行时间：3.135018ms
112, 250, 356, 3336, 4771, 4885, 5176, 6666, 7187, 7898, 8633, 8791, 9121, 11541, 12447, 13435, 14810, 20175, 20525, 22375, 24123, 24331, 26872, 27415, 28299, 30476, 30559, 31015, 31893, 32603, 33177, 33284, 33618, 35567, 35806, 36695, 36779, 37009, 37521, 39966, 41238, 41290, 41520, 42413, 44164, 44455, 44707, 45621, 46148, 46337, 47606, 48833, 49297, 49591, 49733, 49977, 50567, 51465, 51642, 52571, 53440, 53500, 53998, 55129, 55327, 59234, 59411, 59888, 59899, 60917, 62128, 65122, 65157, 65415, 66168, 66497, 67091, 74273, 74414, 76268, 77357, 78099, 78339, 80608, 84736, 86008, 86639, 89042, 89287, 89494, 89540, 90841, 91035, 91396, 93105, 94612, 96446, 98123, 99015, 99760, 
快速排序基本操作执行次数：99次
快速排序执行时间：2.266869ms

②第二次生产100个随机数：
gitpod /workspace/homewrok_template/code (main) $ cd "/workspace/homewrok_template/code/" && javac sort.java && java sort
Picked up JAVA_TOOL_OPTIONS:  -Xmx3435m
Picked up JAVA_TOOL_OPTIONS:  -Xmx3435m
请输入测试数据的数目
100
158, 2193, 2241, 2512, 2532, 3950, 4256, 4470, 4571, 5605, 5660, 6390, 6474, 10871, 11187, 13673, 14787, 14913, 15083, 15767, 15805, 16721, 17655, 17736, 19296, 20219, 21234, 25525, 26036, 27120, 28850, 31422, 31974, 31992, 32571, 33585, 34104, 34304, 34787, 36469, 37888, 41210, 42282, 42779, 43342, 45123, 45284, 45356, 47052, 47060, 53008, 53165, 53627, 54643, 54906, 55933, 56156, 56762, 57725, 59201, 59478, 60156, 62712, 62727, 62909, 63696, 64317, 65173, 66688, 68900, 69292, 69567, 72318, 74840, 77219, 78511, 79135, 79695, 81530, 81898, 82508, 83807, 83842, 85118, 85253, 85607, 86421, 86615, 87117, 87495, 88789, 89415, 92627, 92933, 93123, 93302, 95737, 95746, 96169, 97974, 基本操作执行次数：2504次
冒泡排序执行时间:15.954344ms
158, 2193, 2241, 2512, 2532, 3950, 4256, 4470, 4571, 5605, 5660, 6390, 6474, 10871, 11187, 13673, 14787, 14913, 15083, 15767, 15805, 16721, 17655, 17736, 19296, 20219, 21234, 25525, 26036, 27120, 28850, 31422, 31974, 31992, 32571, 33585, 34104, 34304, 34787, 36469, 37888, 41210, 42282, 42779, 43342, 45123, 45284, 45356, 47052, 47060, 53008, 53165, 53627, 54643, 54906, 55933, 56156, 56762, 57725, 59201, 59478, 60156, 62712, 62727, 62909, 63696, 64317, 65173, 66688, 68900, 69292, 69567, 72318, 74840, 77219, 78511, 79135, 79695, 81530, 81898, 82508, 83807, 83842, 85118, 85253, 85607, 86421, 86615, 87117, 87495, 88789, 89415, 92627, 92933, 93123, 93302, 95737, 95746, 96169, 97974, 
归并排序基本操作执行次数：672次
归并排序执行时间：2.10585ms
158, 2193, 2241, 2512, 2532, 3950, 4256, 4470, 4571, 5605, 5660, 6390, 6474, 10871, 11187, 13673, 14787, 14913, 15083, 15767, 15805, 16721, 17655, 17736, 19296, 20219, 21234, 25525, 26036, 27120, 28850, 31422, 31974, 31992, 32571, 33585, 34104, 34304, 34787, 36469, 37888, 41210, 42282, 42779, 43342, 45123, 45284, 45356, 47052, 47060, 53008, 53165, 53627, 54643, 54906, 55933, 56156, 56762, 57725, 59201, 59478, 60156, 62712, 62727, 62909, 63696, 64317, 65173, 66688, 68900, 69292, 69567, 72318, 74840, 77219, 78511, 79135, 79695, 81530, 81898, 82508, 83807, 83842, 85118, 85253, 85607, 86421, 86615, 87117, 87495, 88789, 89415, 92627, 92933, 93123, 93302, 95737, 95746, 96169, 97974, 
快速排序基本操作执行次数：99次
快速排序执行时间：1.888059ms

(2)算法复杂度分析时输入数据等价类的含义：

### 3.使用随机数生成方法生成不同规模的测试数据对于每种规模的测试数据，分别记录 BubbleSort、MergeSort 和 QuickSort 算法执行中比较操作的执行次数

#### 实验预期结果：冒泡排序的基本操作次数最大，合并排序次之，快速排序最后。

#### 实验过程及实验结果：

(1)代码运行结果：
gitpod /workspace/homewrok_template/code (main) $ python -u "/workspace/homewrok_template/code/01_test.py"
请输入生成随机数的个数10
冒泡排序基本操作执行次数：35
归并排序基本操作执行次数：21
快速排序基本操作执行次数：8

gitpod /workspace/homewrok_template/code (main) $ python -u "/workspace/homewrok_template/code/01_test.py"
请输入生成随机数的个数100
冒泡排序基本操作执行次数：4746
归并排序基本操作执行次数：411
快速排序基本操作执行次数：98

gitpod /workspace/homewrok_template/code (main) $ python -u "/workspace/homewrok_template/code/01_test.py"
请输入生成随机数的个数500
冒泡排序基本操作执行次数：123471
归并排序基本操作执行次数：2695
快速排序基本操作执行次数：498

gitpod /workspace/homewrok_template/code (main) $ python -u "/workspace/homewrok_template/code/01_test.py"
请输入生成随机数的个数1000
冒泡排序基本操作执行次数：498410
归并排序基本操作执行次数：5473
快速排序基本操作执行次数：998

gitpod /workspace/homewrok_template/code (main) $ python -u "/workspace/homewrok_template/code/01_test.py"
请输入生成随机数的个数5000
冒泡排序基本操作执行次数：12492486
归并排序基本操作执行次数：37055
快速排序基本操作执行次数：4998

gitpod /workspace/homewrok_template/code (main) $ python -u "/workspace/homewrok_template/code/01_test.py"
请输入生成随机数的个数2000
冒泡排序基本操作执行次数：1987685
归并排序基本操作执行次数：12379
快速排序基本操作执行次数：1998

gitpod /workspace/homewrok_template/code (main) $ python -u "/workspace/homewrok_template/code/01_test.py"
请输入生成随机数的个数10000
冒泡排序基本操作执行次数：49970295
归并排序基本操作执行次数：79913
快速排序基本操作执行次数：9998

gitpod /workspace/homewrok_template/code (main) $ python -u "/workspace/homewrok_template/code/01_test.py"
请输入生成随机数的个数100000
冒泡排序基本操作执行次数：4999732631
归并排序基本操作执行次数：879532
快速排序基本操作执行次数：99998

(2)加法操作与n的关系曲线图：
①冒泡排序：
![冒泡排序](https://s3.bmp.ovh/imgs/2022/06/19/d77890953798f6fe.png)
②归并排序：
![归并排序](https://s3.bmp.ovh/imgs/2022/06/19/7ece6df5e0ab8832.png)
③快速排序
![快速排序](https://s3.bmp.ovh/imgs/2022/06/19/ff393beafbd7cdfb.png)

（3）实验结果分析：由曲线图分析得出，冒泡排序的曲线图为二次曲线增长趋势，与其理论上O(n^2)的时间复杂度相符；合并排序和快速排序的曲线增长趋势接近于线性曲线趋势，与其理论上的时间复杂度相符合。

（4）理解计算时间渐进性态和增长率的概念：时间复杂度的度量可通过其基本操作的次数与问题规模的关系曲线来反映，即通过曲线的增长率即渐进线态来估计问题的时间复杂度。

### 3.实验结果分析与结论：
经过以上三个小实验，可以清晰地观察出冒泡排序、归并排序、快速排序的增长曲线图，验证了理论结论，帮助我们更牢固的掌握与理解时间复杂度的概念与意义。








